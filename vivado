//SOURCE CODE

module pipeline_cpu (
    input clk,
    input reset,
    output reg [7:0] result
);

    // ---------------------------
    // Instruction Encoding (8-bit)
    // ---------------------------
    // [7:6] opcode | [5:4] rs | [3:2] rt | [1:0] rd
    // opcode: 00=ADD, 01=SUB, 10=AND, 11=LOAD
    // LOAD ignores rs/rt, just loads immediate value

    reg [7:0] instr_mem [0:15];   // 16 instructions
    reg [7:0] regfile [0:3];      // 4 registers (R0-R3)

    // Pipeline registers
    reg [7:0] IF_ID, ID_EX, EX_MEM, MEM_WB;

    // Decode wires
    wire [1:0] opcode, rs, rt, rd;
    assign opcode = IF_ID[7:6];
    assign rs     = IF_ID[5:4];
    assign rt     = IF_ID[3:2];
    assign rd     = IF_ID[1:0];

    reg [7:0] alu_out;

    integer pc;

    // ---------------------------
    // FETCH
    // ---------------------------
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            pc     <= 0;
            IF_ID  <= 0;
            ID_EX  <= 0;
            EX_MEM <= 0;
            MEM_WB <= 0;
            result <= 0;
        end
        else begin
            // pipeline progression
            IF_ID  <= instr_mem[pc];
            ID_EX  <= IF_ID;
            EX_MEM <= ID_EX;
            MEM_WB <= EX_MEM;

            pc <= pc + 1;

            // EXECUTE stage
            case (ID_EX[7:6])
                2'b00: alu_out <= regfile[ID_EX[5:4]] + regfile[ID_EX[3:2]]; // ADD
                2'b01: alu_out <= regfile[ID_EX[5:4]] - regfile[ID_EX[3:2]]; // SUB
                2'b10: alu_out <= regfile[ID_EX[5:4]] & regfile[ID_EX[3:2]]; // AND
                2'b11: alu_out <= {6'b0, ID_EX[1:0]};                       // LOAD imm (just 2-bit value for demo)
            endcase

            // WRITEBACK
            regfile[MEM_WB[1:0]] <= alu_out;
            result <= alu_out;
        end
    end

endmodule

//TESTBENCH

timescale 1ns/1ps
`timescale 1ns/1ps
module tb_pipeline_cpu;

    reg clk, reset;
    wire [7:0] result;

    pipeline_cpu uut (
        .clk(clk),
        .reset(reset),
        .result(result)
    );

    // Clock
    always #5 clk = ~clk;

    initial begin
        clk = 0;
        reset = 1;
        #10 reset = 0;

        // preload registers
        uut.regfile[1] = 8'd5;
        uut.regfile[2] = 8'd3;

        // preload instructions
        // opcode: 00=ADD, 01=SUB, 10=AND, 11=LOAD
        uut.instr_mem[0] = 8'b00_01_10_00; // ADD R1,R2 -> R0  (5+3=8)
        uut.instr_mem[1] = 8'b01_01_10_01; // SUB R1,R2 -> R1  (5-3=2)
        uut.instr_mem[2] = 8'b10_01_10_10; // AND R1,R2 -> R2  (5&3=1)
        uut.instr_mem[3] = 8'b11_00_00_11; // LOAD imm(3) -> R3

        #100 $finish;
    end

endmodule
